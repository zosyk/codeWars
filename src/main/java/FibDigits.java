import java.math.BigInteger;
import java.util.Comparator;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Leonardo Fibonacci
 * A farmer raises rabbits. Each rabbit gives birth to one rabbit when it turns 2 months old, and then to one rabbit each month.
 * Rabbits never die, and we ignore hares. How many rabbits will the farmer have in the n-th month, if he starts with one newborn rabbit?
 * Fibonacci numbers are generated by setting F0=0, F1=1, and then using the formula
 * <p>
 * Fn = Fn-1 + Fn-2
 * <p>
 * Your task is to efficiently calculate the nth element in the Fibonacci sequence and then count the occurrence of each digit in the number returning a list of
 * integer pairs sorted in descending order.
 * <p>
 * 10 ≤ N ≤ 100000
 * <p>
 * f(10)=55 returns
 * <p>
 * a = [(2, 5)]
 * <p>
 * two occurances of the digit 5
 * <p>
 * f(10)=55
 * ^^
 * ||
 * <p>
 * f(10000) returns
 * <p>
 * a = [(254, 3),
 * (228, 2),
 * (217, 6),
 * (217, 0),
 * (202, 5),
 * (199, 1),
 * (198, 7),
 * (197, 8),
 * (194, 4),
 * (184, 9)]
 * If two integers have the same count sort them in descending order.
 * <p>
 * Your algorithm must be efficient.
 * <p>
 * Solving this Kata in Javascript requires the use of the bignumber.js library. I have included starter code to assist you with using the library.
 * Thanks to @kazk for assisting with the translation.
 */
public class FibDigits {


    public static int[][] FibDigits(int n) {
        BigInteger[] fibs = {BigInteger.ZERO, BigInteger.ONE};

        for (int i = 2; i <= n; i++) {
            BigInteger prev = fibs[1];
            fibs[1] = fibs[0].add(fibs[1]);
            fibs[0] = prev;
        }

        BigInteger fib = fibs[1];
        if (n == 1)
            fib = fibs[0];

        return fib.toString()
                .chars().mapToObj(value -> value - '0')
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet().stream()
                .map(e -> new int[]{e.getValue().intValue(), e.getKey()})
                .sorted(Comparator.<int[]>comparingInt(p -> p[0]).thenComparing(p -> p[1]).reversed())
                .toArray(int[][]::new);
    }

}
